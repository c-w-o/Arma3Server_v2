name: Project Scan

on: [push]

jobs:
  pylint:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.8", "3.9", "3.10"]
    steps:
    - uses: actions/checkout@v6
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v6
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pylint
    - name: Analysing the code with pylint
      run: |
        # Create a temporary file to capture pylint output
        pylint_output_file="pylint_output.txt"
        
        # Run pylint and capture output (both stdout and stderr)
        pylint $(git ls-files '*.py') > "$pylint_output_file" 2>&1 || true
        
        # Show output in console
        cat "$pylint_output_file"
        
        # Use awk to parse and format the entire summary
        awk -v python_version="${{ matrix.python-version }}" '
        BEGIN {
          # Initialize counters
          score = "N/A"
          fatal = 0; error = 0; warning = 0; convention = 0; refactor = 0
          
          # Print header
          print "## üîç Pylint Analysis Results (Python " python_version ")"
          print ""
        }
        
        # Extract score
        /Your code has been rated at [0-9.]+/ {
          if (match($0, /rated at ([0-9.]+)/, arr)) {
            score = arr[1]
          }
        }
        
        # Process each line to count issues
        {
          # Try to match pylint message pattern: file:line:column: message_code: description
          if (match($0, /^([^:]+):[0-9]+:[0-9]+: [A-Z]([0-9]+):/)) {
            # Extract filename (everything before first colon)
            file = substr($0, RSTART, RLENGTH)
            sub(/:[0-9]+:[0-9]+:.*/, "", file)
            
            # Extract the message code (first character)
            code = substr($0, RSTART + RLENGTH - 6, 1)  # Position of message code
            
            # Update global counters
            if (code == "F") {
              fatal++
              f[file]++
            } else if (code == "E") {
              error++
              e[file]++
            } else if (code == "W") {
              warning++
              w[file]++
            } else if (code == "C") {
              convention++
              c[file]++
            } else if (code == "R") {
              refactor++
              r[file]++
            }
            
            # Track total per file
            total[file]++
          }
        }
        
        END {
          # Calculate totals
          total_issues = fatal + error + warning + convention + refactor
          
          # Print category breakdown
          print "### Summary"
          print ""
          print "| Category | Count | Description |"
          print "|----------|-------|-------------|"
          printf "| **Score** | %s/10 | Global Score of the Codebase |\n", score
          printf "| **Total Issues** | %d | Total Number of Issues |\n", total_issues
          printf "| **Fatal (F)** | %d | Fatal errors preventing analysis |\n", fatal
          printf "| **Error (E)** | %d | Programming errors |\n", error
          printf "| **Warning (W)** | %d | Style warnings |\n", warning
          printf "| **Convention (C)** | %d | Coding standards |\n", convention
          printf "| **Refactor (R)** | %d | Code refactoring suggestions |\n", refactor
          print ""
          
          # Print file-by-file analysis
          print "### File Overview"
          print ""
          
          if (length(total) == 0) {
            print "üéâ No issues found in any files!"
            print ""
          } else {
            print "Files sorted by total issues (descending):"
            print ""
            
            # Count number of files
            file_count = 0
            for (file in total) {
              file_count++
            }
            
            # Create arrays for sorting
            for (i = 0; i < file_count; i++) {
              # We need to populate these in a separate loop
              # First, collect all files
              j = 0
              for (file in total) {
                files[j] = file
                totals[j] = total[file]
                j++
              }
            }
            
            # Simple bubble sort by total issues (descending)
            n = file_count
            for (i = 0; i < n-1; i++) {
              for (j = 0; j < n-i-1; j++) {
                if (totals[j] < totals[j+1]) {
                  # Swap totals
                  temp_total = totals[j]
                  totals[j] = totals[j+1]
                  totals[j+1] = temp_total
                  
                  # Swap files
                  temp_file = files[j]
                  files[j] = files[j+1]
                  files[j+1] = temp_file
                }
              }
            }
            
            # Print sorted files with counts
            for (i = 0; i < n; i++) {
              file = files[i]
              file_f = (file in f) ? f[file] : 0
              file_e = (file in e) ? e[file] : 0
              file_w = (file in w) ? w[file] : 0
              file_c = (file in c) ? c[file] : 0
              file_r = (file in r) ? r[file] : 0
              file_total = totals[i]
              
              printf "  - **%s** [F:%d, E:%d, W:%d, C:%d, R:%d, Total:%d]\n",
                file, file_f, file_e, file_w, file_c, file_r, file_total
            }
            print ""
          }
          
          # Print detailed output section
          print "### Workflow Output"
          print ""
          print "<details>"
          print "<summary>Click to view full pylint output</summary>"
          print ""
          print "```"
        }
        ' "$pylint_output_file" >> "$GITHUB_STEP_SUMMARY"
        
        # Append the actual pylint output to the summary
        cat "$pylint_output_file" >> "$GITHUB_STEP_SUMMARY"
        
        # Close the code block and details tag
        echo '```' >> "$GITHUB_STEP_SUMMARY"
        echo '</details>' >> "$GITHUB_STEP_SUMMARY"
        echo '' >> "$GITHUB_STEP_SUMMARY"
        
        # Check if there are errors and optionally fail
        # Extract error count from the file for conditional exit
        error_count=$(grep -c -E ':[[:space:]]+[EF][0-9]+:' "$pylint_output_file" 2>/dev/null || echo "0")
        if [ "$error_count" -gt 0 ]; then
          echo "::warning::Pylint found $error_count error(s)"
          # Uncomment below to fail the workflow on errors:
          # exit 1
        fi

  bandit:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.8", "3.9", "3.10"]
    permissions:
      # required for all workflows
      security-events: write
      # only required for workflows in private repositories
      actions: read
      contents: read
    steps:
      - name: Perform Bandit Analysis with ${{ matrix.python-version }}
        uses: PyCQA/bandit-action@v1
  anchore:
    runs-on: ubuntu-latest
    steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: build local container
      uses: docker/build-push-action@v6
      with:
        tags: localbuild/testimage:latest
        push: false
        load: true
    
    - name: Scan image
      uses: anchore/scan-action@v7
      id: scan
      with:
        image: "localbuild/testimage:latest"
        fail-build: false
    - name: Upload Anchore scan SARIF report
      uses: github/codeql-action/upload-sarif@v4
      with:
        sarif_file: ${{ steps.scan.outputs.sarif }}
    - name: Inspect action SARIF report
      run: cat ${{ steps.scan.outputs.sarif }}
